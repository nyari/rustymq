//! This module contains the functionality for executing a client that sends an operation to a server
//! capable of handling requests on multiple threads.

use rand::Rng;
/// Importing to handle TypedMessages from RustyMQ
use rustymq::base::{TypedMessage, Message, BidirectionalSocket, OpFlag};
use super::time::{Duration};

use super::data;

/// Implementation of a client that sends messages to a server that handles [`data::OperationTask`]s.
pub struct OperationClient<Socket>
    where Socket: BidirectionalSocket + 'static {
    socket: Socket
}

impl<Socket> OperationClient<Socket>
    where Socket: BidirectionalSocket + 'static {
    /// Create a new OperationServer that listents for tasks on the [`BidirectionalSocket`]
    pub fn new(socket: Socket) -> Self {
        Self {
            socket: socket
        }
    }

    fn create_random_operation() -> data::OperationTask{
        // Create a random number generation to generate operations to execute on server
        let mut rnd = rand::thread_rng();
        // Generate the random operation to execute
        match rnd.gen_range(0, 1) {
            0 => {
                data::OperationTask::Addition(rnd.gen_range(-1000, 1000), rnd.gen_range(-1000, 1000))
            },
            1 => {
                data::OperationTask::Multiplication(rnd.gen_range(-1000, 1000), rnd.gen_range(-1000, 1000))
            },
            _ => panic!("Impossible random")
        }
    }

    /// Start executing the server on `threadcount` number of threads
    pub fn execute_client(self) {
        // Start an infinite loop to send messages
        loop {
            // Get a random operation
            let operation = Self::create_random_operation();
            // Assemple a message that we can send. We can use [`TypedMessage`] because we have implemented
            // [`SerializableMessagePayload`] for [`data::TimedOperation`].
            let message = TypedMessage::new(
                        //Create the [`TimedOperation`] wrapper around the operation, to be able to measure the round trip time
                data::TimedOperation(operation, Duration::now())).ensure_random_conversation_id();
            // Print out the converstation id for the message (this was randomly generated by MessageMetadata internally on creation of the TypedMessage)
            println!("Request:  Conversation: {}", message.conversation_id().unwrap().get());
            
            // Send the typed message through the socket to the server
            // Here we have to note that we unwrap the result. This means that if the server disconnects or other issue happens
            // then the application will panic. For further details on the possbile error check [`rustymq::base::SocketError`] and
            // [`rustymq::base::SendTypedError`] documentation
            // Also by using the OpFlag::Wait means that the operation will block until the message is written to the output socket
            self.socket.send_typed(message, OpFlag::Wait).unwrap();

            // Received the result calculated by the server
            // Here we also use the OpFlag::Wait, which means the operation will block until an actual message is received
            // In case the OpFlag::NoWait was used then if there is no message in queue then a Timeout error would be given
            let result = self.socket.receive_typed::<data::TimedOperation<data::OperationResult>>(OpFlag::Wait).unwrap();

            // Calulate the elapsed time since the creation of the original request message
            let elapsed_duration = Duration::now().0 - result.payload().1.0;
            // Print out the conversation id for the received message, and also the elapsed times since the creation of the original request message
            println!("Response: Conversation: {}. Elapsed milisecs: {}", result.conversation_id().unwrap().get(), elapsed_duration.as_millis()); 
        }
    }
}